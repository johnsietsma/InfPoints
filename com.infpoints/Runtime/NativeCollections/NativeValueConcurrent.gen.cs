
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Threading;
using Unity.Collections.LowLevel.Unsafe;

namespace InfPoints
{


    public unsafe partial struct NativeInt
    {
        /// <summary>
        /// A concurrent version of <c>NativeInt</c>.
        /// It contains only write methods and as usable in IJobParallelFor jobs.
        /// </summary>
        [NativeContainer]
        [NativeContainerIsAtomicWriteOnly]
        public struct Concurrent
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public AtomicSafetyHandle m_Safety;
#endif
            
            [NativeDisableUnsafePtrRestriction]
            readonly int* m_Buffer;

            /// <summary>
            /// Create a new NativeInt with an initial value of 0.
            /// </summary>
            /// <param name="allocatorLabel"></param>
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public Concurrent(int* buffer, AtomicSafetyHandle safety)
            {
                m_Buffer = buffer;
                m_Safety = safety;
            }
#endif
            
            public Concurrent(int* buffer)
            {
                m_Buffer = buffer;
                m_Safety = default;
            }

        public int Value
        {
            [WriteAccessRequired]
            set
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Exchange(ref *m_Buffer, value);
            }
        }
            
            [WriteAccessRequired]
            public void Add(int value)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Add(ref *m_Buffer, value);
            }

            [WriteAccessRequired]
            public void Increment()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Increment(ref *m_Buffer);
            }

            [WriteAccessRequired]
            public void Decrement()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Decrement(ref *m_Buffer);
            }
        }
    }


    public unsafe partial struct NativeLong
    {
        /// <summary>
        /// A concurrent version of <c>NativeLong</c>.
        /// It contains only write methods and as usable in IJobParallelFor jobs.
        /// </summary>
        [NativeContainer]
        [NativeContainerIsAtomicWriteOnly]
        public struct Concurrent
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public AtomicSafetyHandle m_Safety;
#endif
            
            [NativeDisableUnsafePtrRestriction]
            readonly long* m_Buffer;

            /// <summary>
            /// Create a new NativeLong with an initial value of 0.
            /// </summary>
            /// <param name="allocatorLabel"></param>
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public Concurrent(long* buffer, AtomicSafetyHandle safety)
            {
                m_Buffer = buffer;
                m_Safety = safety;
            }
#endif
            
            public Concurrent(long* buffer)
            {
                m_Buffer = buffer;
                m_Safety = default;
            }

        public long Value
        {
            [WriteAccessRequired]
            set
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Exchange(ref *m_Buffer, value);
            }
        }
            
            [WriteAccessRequired]
            public void Add(long value)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Add(ref *m_Buffer, value);
            }

            [WriteAccessRequired]
            public void Increment()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Increment(ref *m_Buffer);
            }

            [WriteAccessRequired]
            public void Decrement()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Decrement(ref *m_Buffer);
            }
        }
    }


}