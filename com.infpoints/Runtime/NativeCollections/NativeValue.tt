<#/*THIS IS A T4 FILE*/#>
<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Threading;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace InfPoints
{

<#
var TYPES = new []{"Int","Long"};
foreach (var typeName in TYPES)
{
    var type = typeName.ToLower();
#>
    /// <summary>
    /// Use a simple <#=type#> as a NativeContainer. This allows data to be passed out of a Job without having to create
    /// a new NativeArray to hold a single value.
    /// Use <c>Native<#=typeName#>.Concurrent</c> in IJobParallelFor jobs. 
    /// Supports the [DeallocateOnJobCompletion] attribute.
    /// </summary>
    [NativeContainer]
    [NativeContainerSupportsDeallocateOnJobCompletion]
    [DebuggerTypeProxy(typeof(Native<#=typeName#>DebugView))]
    [DebuggerDisplay("Value = {Value}")]
    public unsafe partial struct Native<#=typeName#> : IDisposable
    {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle m_Safety;
        [NativeSetClassTypeToNullOnSchedule] DisposeSentinel m_DisposeSentinel;
        static readonly int DisposeSentinelStackDepth = 2;
#endif

        /// <summary>
        /// Has the value been created and not yet destroyed.
        /// Be aware that this will fail if a copy of the struct is taken, say for example by a job.
        /// A copy of the pointer is made and wont be set to null when the NativeInt is Disposed.
        /// </summary>
        public bool IsCreated => m_Buffer != null;

        [NativeDisableUnsafePtrRestriction] <#=type#>* m_Buffer;
        readonly Allocator m_AllocatorLabel;
        
        /// <summary>
        /// Create a new Native<#=typeName#> with an initial value of 0.
        /// </summary>
        /// <param name="allocatorLabel"></param>
        public Native<#=typeName#>(Allocator allocatorLabel) : this(0, allocatorLabel)
        {
        }

        /// <summary>
        /// Create a new NativeValue with an initial value.
        /// </summary>
        public Native<#=typeName#>(<#=type#> initialValue, Allocator allocatorLabel)
        {
            m_Buffer = (<#=type#>*) UnsafeUtility.Malloc(UnsafeUtility.SizeOf<<#=type#>>(), UnsafeUtility.AlignOf<<#=type#>>(),
                allocatorLabel);
            m_AllocatorLabel = allocatorLabel;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, DisposeSentinelStackDepth, allocatorLabel);
#endif
            *m_Buffer = initialValue;
        }

        public <#=type#> Value
        {
            get
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckReadAndThrow(m_Safety);
#endif
                return *m_Buffer;
            }
            [WriteAccessRequired]
            set
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Exchange(ref *m_Buffer, value);
            }
        }

        [WriteAccessRequired]
        public void Add(<#=type#> value)
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
            Interlocked.Add(ref *m_Buffer, value);
        }

        [WriteAccessRequired]
        public void Increment()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
            Interlocked.Increment(ref *m_Buffer);
        }

        [WriteAccessRequired]
        public void Decrement()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
            Interlocked.Decrement(ref *m_Buffer);
        }

        public Concurrent ToConcurrent()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            var concurrent = new Concurrent(m_Buffer, m_Safety);
            AtomicSafetyHandle.UseSecondaryVersion(ref concurrent.m_Safety);
#else
            var concurrent = new Concurrent(m_Buffer);
#endif
            return concurrent;
        }

        [WriteAccessRequired]
        public void Dispose()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
            DisposeSentinel.Dispose(ref m_Safety, ref m_DisposeSentinel);
#endif
            if (m_Buffer != null)
                Deallocate();
        }

        void Deallocate()
        {
            UnsafeUtility.Free(m_Buffer, m_AllocatorLabel);
            m_Buffer = null;
        }

        [BurstCompile]
        struct DisposeJob : IJob
        {
            public Native<#=typeName#> Value;

            public void Execute()
            {
                Value.Deallocate();
            }
        }

        /// <summary>
        /// Safely disposes of this container and deallocates its memory when the jobs that use it have completed.
        /// </summary>
        /// <remarks>You can call this function dispose of the container immediately after scheduling the job. Pass
        /// the [JobHandle](https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html) returned by
        /// the [Job.Schedule](https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html)
        /// method using the `jobHandle` parameter so the job scheduler can dispose the container after all jobs
        /// using it have run.</remarks>
        /// <param name="dependency">All jobs spawned will depend on this JobHandle.</param>
        /// <returns>A new job handle containing the prior handles as well as the handle for the job that deletes
        /// the container.</returns>
        public JobHandle Dispose(JobHandle dependency)
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            DisposeSentinel.Clear(ref m_DisposeSentinel);
#endif

            var jobHandle = new DisposeJob {Value = this}.Schedule(dependency);

#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.Release(m_Safety);
#endif

            return jobHandle;
        }
    }

    internal sealed class Native<#=typeName#>DebugView
    {
        private Native<#=typeName#> m_Value;

        public Native<#=typeName#>DebugView(Native<#=typeName#> value)
        {
            m_Value = value;
        }

        public <#=type#> Value => m_Value.Value;
    }
<#
}
#>

}