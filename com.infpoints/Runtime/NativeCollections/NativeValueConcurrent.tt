<#/*THIS IS A T4 FILE*/#>
<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Threading;
using Unity.Collections.LowLevel.Unsafe;

namespace InfPoints.NativeCollections
{

<#
var TYPES = new []{"Int","Long"};
foreach (var typeName in TYPES)
{
    var type = typeName.ToLower();
#>

    public unsafe partial struct Native<#=typeName#>
    {
        /// <summary>
        /// A concurrent version of <c>Native<#=typeName#></c>.
        /// It contains only write methods and as usable in IJobParallelFor jobs.
        /// </summary>
        [NativeContainer]
        [NativeContainerIsAtomicWriteOnly]
        public struct Concurrent
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public AtomicSafetyHandle m_Safety;
#endif
            
            [NativeDisableUnsafePtrRestriction]
            readonly <#=type#>* m_Buffer;

            /// <summary>
            /// Create a new Native<#=typeName#> with an initial value of 0.
            /// </summary>
            /// <param name="allocatorLabel"></param>
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            public Concurrent(<#=type#>* buffer, AtomicSafetyHandle safety)
            {
                m_Buffer = buffer;
                m_Safety = safety;
            }
#endif
            
            public Concurrent(<#=type#>* buffer)
            {
                m_Buffer = buffer;
                m_Safety = default;
            }

        public <#=type#> Value
        {
            [WriteAccessRequired]
            set
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Exchange(ref *m_Buffer, value);
            }
        }
            
            [WriteAccessRequired]
            public void Add(<#=type#> value)
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Add(ref *m_Buffer, value);
            }

            [WriteAccessRequired]
            public void Increment()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Increment(ref *m_Buffer);
            }

            [WriteAccessRequired]
            public void Decrement()
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
                Interlocked.Decrement(ref *m_Buffer);
            }
        }
    }

<#
}
#>

}