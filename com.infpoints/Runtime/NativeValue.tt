<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Threading;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace InfPoints
{

<#
var types = new[]{"float","double","int","long"};
foreach(var type in types)
{
#>
    /// <summary>
    /// Use a simple <#=type#> as a NativeContainer. This allows data to be passed out of a Job without having to create
    /// a new NativeArray to hold a single value.
    /// </summary>
    /// <typeparam name="T">An unmanaged type</typeparam>
    [NativeContainer]
    public unsafe struct Native<#=type#><T> : IDisposable
        where T : unmanaged
    {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle m_Safety;

        [NativeSetClassTypeToNullOnSchedule] DisposeSentinel m_DisposeSentinel;
        static readonly int DisposeSentinelStackDepth = 2;
#endif

        /// <summary>
        /// Has the value been created and not yet destroyed.
        /// Be aware that this will fail if a copy of the struct is taken, say for example by a job.
        /// A copy of the pointer is made and wont be set to null when the Native<#=type#> is Disposed.
        /// </summary>
        public bool IsCreated => m_Buffer != null;

        public T Value
        {
            get
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckReadAndThrow(m_Safety);
                if (m_Buffer == null) throw new NullReferenceException();
#endif
                return *m_Buffer;
            }
            set
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
                if (m_Buffer == null) throw new NullReferenceException();
#endif
                Interlocked.Exchange(ref *m_Buffer,value);
            }
        }

        [NativeDisableUnsafePtrRestriction] 
        <#=type#>* m_Buffer;
        readonly Allocator m_AllocatorLabel;

        /// <summary>
        /// Create a new NativeValue with an initial value.
        /// </summary>
        public NativeValue(<#=type#> initialValue, Allocator allocatorLabel)
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, DisposeSentinelStackDepth, allocatorLabel);
#endif
            m_Buffer = (<#=type#>*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<T>(), UnsafeUtility.AlignOf<T>(), allocatorLabel);
            m_AllocatorLabel = allocatorLabel;
            *m_Buffer = initialValue;
        }


        public void Dispose()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            DisposeSentinel.Dispose(ref m_Safety, ref m_DisposeSentinel);
#endif
            if (m_Buffer != null)
                Deallocate();
        }

        void Deallocate()
        {
            UnsafeUtility.Free(m_Buffer, m_AllocatorLabel);
            m_Buffer = null;
        }

        [BurstCompile]
        struct DisposeJob : IJob
        {
            public Native<#=type#> Value;

            public void Execute()
            {
                Value.Deallocate();
            }
        }

        /// <summary>
        /// Safely disposes of this container and deallocates its memory when the jobs that use it have completed.
        /// </summary>
        /// <remarks>You can call this function dispose of the container immediately after scheduling the job. Pass
        /// the [JobHandle](https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html) returned by
        /// the [Job.Schedule](https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobExtensions.Schedule.html)
        /// method using the `jobHandle` parameter so the job scheduler can dispose the container after all jobs
        /// using it have run.</remarks>
        /// <param name="dependency">All jobs spawned will depend on this JobHandle.</param>
        /// <returns>A new job handle containing the prior handles as well as the handle for the job that deletes
        /// the container.</returns>
        public JobHandle Dispose(JobHandle dependency)
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            DisposeSentinel.Clear(ref m_DisposeSentinel);
#endif

            var jobHandle = new DisposeJob {Value = this}.Schedule(dependency);

#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.Release(m_Safety);
#endif

            return jobHandle;
        }
    }
<#
}
#>
}
